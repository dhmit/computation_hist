{% extends "base_simulation.jinja2" %}

{% block title %}Floating-Point Operations{% endblock %}

{% block self %}Floating-Point Operations{% endblock %}

{% block code %}
    <p class="symbolic_code" id = "symbolic_code0">CLA 10</p>
    <p class="symbolic_code" id = "symbolic_code1">FAD 11</p>
    <p class="symbolic_code" id = "symbolic_code2">STO 12</p>
    <br />
    <p class="symbolic_code" id = "symbolic_code3">ORG 10</p>
    <p class="symbolic_code" id = "symbolic_code4">DEC -2.54</p>
    <p class="symbolic_code" id = "symbolic_code5">DEC 6.98</p>
{% endblock %}

{% block description %}
    This example is similar to the .<br />
    <b>PZE 5: </b> This is an example of what's called a psuedoinstruction.  A psuedoinstruction doesn't correspond to an actual instruction the computer can do.
    PZE 5 means that we basically program a blank instruction with an address of 5.  This is useful because...<br />
    <b>LXA 5, 1: </b> This means load the word at address 5 (which corresponds to PZE 5 as the fifth
    line of code) and store its address into the index register corresponding to 1, which is index register A.<br />
    <b>CLA 7: </b> Just stores the value at address 7 into the accumulator.<br />
    <b>ADD 7: </b> And then add the value at address 7 to the accumulator.<br />
    <b>STO 7: </b> And then store the value of the accumulator to address 7.  Nothing too fancy here.  But then...<br />
    <b>TIX 2, 1, 1: </b> This instruction has four parts, the operation, the address, a tag corresponding to the index register 1 (A), and the last number, the decrement.  What will happen is that
    the computer will compare the value of index register A to the decrement.  If the index register is greater than the decrement, then we subtract the decrement from the index register and jump
    to the specified address, otherwise we continue.  Do you see how this works?  The first time we reach this instruction, the index register is 5, so we subtract 1 to get 4 and jump back to the
    instruction at address 2, which is ADD 7.  Then the next time the index register will be 4... then 3... then 2... then 1... and then the program will be done running.  You can see this if you
    step through the program.  At the end, register 7 should have a value of 2^5, 32, from repeated adding.  <br />
    This is maybe not the best way to compute powers of 2, but it's sufficient for this
    demonstration.<br />
{% endblock %}